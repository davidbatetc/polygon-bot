from cl.polygons import *

if __name__ is not None and "." in __name__:
    from .PolyParser import PolyParser
    from .PolyVisitor import PolyVisitor
else:
    from PolyParser import PolyParser
    from PolyVisitor import PolyVisitor


class PolyEval(PolyVisitor):
    """
    Class used to evaluate parse trees of the language defined in 'Poly.g'.

    This class inherits from the class 'PolyVisitor', which is automatically
     generated by ANTLR.
    """

    def __init__(self):
        """
        Constructor of the PolyEval class.

        This constructor creates an attribute self.polyDict, which is a dictionary
         that contains all the convex polygons of the program. The keys of the
         convex polygons are the identifiers assigned to the convex polygons by the user.
        """
        self.polyDict = {}

    def visitRoot(self, ctx: PolyParser.RootContext):
        """
        Visits the root of the parse tree and returns the output (a string) of
         the visit and a list with the names of the image files generated.
        """
        output = ''
        imageFileNames = []
        for li in ctx.getChildren():
            outi = self.visit(li)
            imagePrefix = 'Image: '
            textPrefix = 'Text: '
            if outi is not None:
                if outi.startswith(imagePrefix):
                    imageFileNames.append(outi[len(imagePrefix):-1])
                elif outi.startswith(textPrefix):
                    output = output + outi[len(imagePrefix)-1:]
                else:
                    output = output + outi
        return output, imageFileNames

    def visitStmt(self, ctx: PolyParser.StmtContext):
        """
        Visits a statement node of the parse tree and returns a string containing
         the generated output or nothing if the statement does not generate an output.
        """
        l = list(ctx.getChildren())
        n = len(l)
        keyWord = l[0].getSymbol().type

        if keyWord == PolyParser.IDEN:
            self.polyDict[l[0].getText()] = self.visit(l[2])
        elif keyWord == PolyParser.COLOR:
            poly = self.polyDict[l[1].getText()]
            poly.color = self.visit(l[3])
        elif keyWord == PolyParser.PRINT:
            if type(l[1]) == PolyParser.PolyContext:
                return str(self.visit(l[1])) + '\n'
            elif l[1].getSymbol().type == PolyParser.QTEXT:
                return 'Text: ' + l[1].getText()[1:-1] + '\n'
        elif keyWord == PolyParser.AREA:
            return '{:.3f}'.format(self.visit(l[1]).area()) + '\n'
        elif keyWord == PolyParser.PERIM:
            return '{:.3f}'.format(self.visit(l[1]).perimeter()) + '\n'
        elif keyWord == PolyParser.VERT:
            return str(self.visit(l[1]).numberOfVertices()) + '\n'
        elif keyWord == PolyParser.CENTR:
            return str(self.visit(l[1]).centroid()) + '\n'
        elif keyWord == PolyParser.INSIDE:
            poly1 = self.visit(l[1])
            poly2 = self.visit(l[3])
            yn = poly2.isPolygonInside(poly1)
            if yn:
                return 'yes' + '\n'
            else:
                return 'no' + '\n'
        elif keyWord == PolyParser.EQUAL:
            poly1 = self.visit(l[1])
            poly2 = self.visit(l[3])
            yn = ConvexPolygon.isEqual(poly1, poly2)
            if yn:
                return 'yes' + '\n'
            else:
                return 'no' + '\n'
        elif keyWord == PolyParser.DRAW:
            fileName = l[1].getText()[1:-1]
            polys = [self.visit(l[i]) for i in range(3, n, 2)]
            ConvexPolygon.draw(polys, fileName=fileName)
            return 'Image: ' + fileName + '\n'
        elif keyWord == PolyParser.TRANS:
            name = l[1].getText()
            u = Vector(float(l[3].getText()), float(l[4].getText()))
            self.polyDict[name].translate(u)
        elif keyWord == PolyParser.ROTATE:
            name = l[1].getText()
            angle = float(l[3].getText())
            self.polyDict[name].rotate(angle)
        elif keyWord == PolyParser.SCALE:
            name = l[1].getText()
            factor = float(l[3].getText())
            self.polyDict[name].scale(factor)

    def visitPoly(self, ctx: PolyParser.PolyContext):
        """Visits a polygon node of the parse tree and returns the corresponding polygon."""

        l = list(ctx.getChildren())
        n = len(l)

        if type(l[0]) == PolyParser.PolyContext:
            opType = l[1].getSymbol().type
            if opType == PolyParser.INTER:
                return ConvexPolygon.intersect(self.visit(l[0]), self.visit(l[2]))

            elif opType == PolyParser.UNION:
                return ConvexPolygon.convexUnion(self.visit(l[0]), self.visit(l[2]))
        else:
            keyWord = l[0].getSymbol().type
            if keyWord == PolyParser.LSQUARE:
                if n == 2:
                    return ConvexPolygon()

                return ConvexPolygon(
                    [Point(float(l[i].getText()), float(l[i + 1].getText()))
                     for i in range(1, n - 1, 2)])

            elif keyWord == PolyParser.LPAREN:
                return self.visit(l[1])
            elif keyWord == PolyParser.BOUND:
                return self.visit(l[1]).boundingBox()
            elif keyWord == PolyParser.COPY:
                return copy.deepcopy(self.polyDict[l[1].getText()])
            elif keyWord == PolyParser.IDEN:
                return self.polyDict[l[0].getText()]
            elif keyWord == PolyParser.REGPOLY:
                return ConvexPolygon.genRegularPolygon(
                    n=int(l[1].getText()),
                    r=float(l[3].getText()),
                    c=Point(float(l[5].getText()), float(l[6].getText())),
                    phase=float(l[8].getText())
                )
            elif keyWord == PolyParser.RAND:
                return ConvexPolygon.random(int(l[1].getText()))

    def visitColor(self, ctx: PolyParser.PolyContext):
        """Visits a color node of the parse tree and returns the corresponding color."""

        # Defined to make the code easier to read
        l = list(ctx.getChildren())
        r = float(l[1].getText())
        g = float(l[2].getText())
        b = float(l[3].getText())
        return Color(r, g, b)
